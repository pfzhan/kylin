options {
    IGNORE_CASE = true;
    STATIC = false;
    UNICODE_INPUT=true;
}

PARSER_BEGIN(EscapeParser)
package io.kyligence.kap.query.util;

import java.io.StringReader;
import java.util.List;
import java.util.Scanner;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import io.kyligence.kap.common.obf.IKeep;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class EscapeParser implements IKeep {

    private static final String CEIL_FLOOR_EXCEPTION_MSG = "%s(exp to timeunit) encounters timeunit %s, but only supports %s";
    private static final String EXTRACT_FROM_EXCEPTION_MSG = "extract(timeunit from exp) encounters timeunit %s, but only supports %s";
    private static final String TIMESTAMP_DIFF_ADD_EXCEPTION_MSG = "%s(timeunit, exp1, exp2) encounters timeunit %s, but only supports %s";

    private EscapeDialect dialect = EscapeDialect.DEFAULT;

    public static void main(String[] args) throws ParseException {
        System.out.println("Input SQL:");
        Scanner reader = new Scanner(System.in);
        String sql = reader.nextLine();
        reader.close();
        EscapeParser parser = new EscapeParser(new StringReader(sql));
        String parseResult = parser.Input();
        System.out.println("Translated SQL:");
        System.out.println(parseResult);
    }

    public EscapeParser(EscapeDialect newDialect, String sql) {
        this(new StringReader(sql));
        this.dialect = newDialect;
    }
}

PARSER_END(EscapeParser)

<ESCAPE, FUNCTION, TIMEUNIT >
SKIP :
{
  < SKIP_SPACE : <SPACE> >
}

< DEFAULT >
TOKEN :
{
  < LBRACE : "{" > : ESCAPE
| < RBRACE : "}" >
| < RPAREN : ")" >
| < LPAREN : "(" >
| < COMMA : "," >
| < SPACE : [" ", "\t","\n", "\r"] >
| < QUOTE: "'" >
| < QUOTED_STRING: <QUOTE> ( (~["'"]) | ("''"))* <QUOTE> >
| < DOUBLE_QUOTE : "\"">
| < QUOTED_IDENTIFIER: <DOUBLE_QUOTE> ( (~["\"","\n","\r"]) | ("\"\"") )+ <DOUBLE_QUOTE> >
| < DOT : "." >
| < BANGEQUAL : "!=" >
| < CEIL : "CEIL" >
| < FLOOR : "FLOOR" >
| < TO : "TO" >
| < SUBSTRING : "SUBSTRING" >
| < SUBSTR :  "SUBSTR" >
| < FROM : "FROM" >
| < FOR : "FOR" >
| < CAST : "CAST" >
| < AS : "AS" >
| < TIMESTAMPADD : "TIMESTAMPADD" >
| < TIMESTAMPDIFF : "TIMESTAMPDIFF" >
| < EXTRACT : "EXTRACT" >
| < ANY : (~[ "{", "}", " ", "(", ")", ",", "'", "\t", "\n", "\r", "\"", ".",
    "=", ">", "<", "?", ":", "!", "+", "-", "*", "/", "%", "|", "^", "$" ])+ >
}

<DEFAULT> TOKEN :
{
    < EQ: "=" >
|   < GT: ">" >
|   < LT: "<" >
|   < HOOK: "?" >
|   < COLON: ":" >
|   < NOT: "!" >
|   < PLUS: "+" >
|   < MINUS: "-" >
|   < STAR: "*" >
|   < SLASH: "/" >
|   < MOD: "%" >
|   < VERTICAL_BAR: "|" >
|   < CARET: "^" >
|   < DOLLAR: "$" >
}

< ESCAPE >
TOKEN :
{
  < FN : "fn" > : FUNCTION
| < TS : "ts" > : DEFAULT
| < D : "d" > : DEFAULT
| < DATE : "date" > : DEFAULT
| < T : "t" > : DEFAULT
| < TIME : "time" > : DEFAULT
}

< FUNCTION >
TOKEN :
{
  < FUNCTION_NAME : <ANY> > : DEFAULT
}

/** Root production. */
String Input() :
{
    String innerString;
    StringBuilder transformedStr = new StringBuilder();
}
{
    (
    LOOKAHEAD(2)
    innerString = Expression()
    {
        transformedStr.append(innerString);
    }
    )+
    <EOF>
    {
        return transformedStr.toString();
    }
}

/** Brace counting production. */
String Expression() :
{
    String innerString = "";
}
{
    {
        if (Thread.currentThread().isInterrupted()) {
            throw new ParseException("EscapeParser is interrupted");
        }
    }
    (
        innerString = EscapeExpress()
    | innerString = SubstringExpression()
    | innerString = TsDiffOrAddExpression()
    | innerString = CastExpression()
    | innerString = ExtractExpression()
    | innerString = CeilFloorExpress()
    | innerString = ParenExpress()
    | innerString = QuotedString()
    | innerString = DoubleQuotedString()
    | innerString = BangEqual()
    | innerString = Comma()
    | innerString = Space()
    | innerString = Punctuation()
    | innerString = From()
    | innerString = For()
    | innerString = To()
    | innerString = As()
    | innerString = Any()
    )
    {
        return innerString;
    }
}

String Comma() :
{}
{
    < COMMA >
    {
        log.trace("meet token <COMMA>");
        return getToken(0).image;
    }
}

String Space() :
{}
{
    < SPACE >
    {
        log.trace("meet token <SPACE>");
        return getToken(0).image;
    }
}

String Punctuation() :
{}
{
    (<DOT> | <EQ> | <GT> | <LT> | <HOOK> | <COLON> | <NOT>| <PLUS>
        | <MINUS> | <STAR> | <SLASH> | <MOD> | <VERTICAL_BAR> | <CARET> | <DOLLAR> )
    {
        log.trace("meet token {}", getToken(0).toString());
        return getToken(0).image;
    }
}

String From() :
{}
{
    < FROM >
    {
        log.trace("met token <FROM>");
        return getToken(0).image;
    }
}

String For() :
{}
{
    < FOR >
    {
        log.trace("met token <FOR>");
        return getToken(0).image;
    }
}

String To() :
{}
{
    < TO >
    {
        log.trace("met token <TO>");
        return getToken(0).image;
    }
}

String As() :
{}
{
    < AS >
    {
        log.trace("met token <AS>");
        return getToken(0).image;
    }
}

String DoubleQuotedString() :
{}
{
    <QUOTED_IDENTIFIER>
    {
        return dialect.transformDoubleQuoteString(getToken(0).image);
    }
}

String QuotedString() :
{
    String s;
}
{
    <QUOTED_STRING>
    {
        log.trace("meet token in <QUOTED_STRING>: " + getToken(0).image);
        return getToken(0).image;
    }
}

String Any() :
{}
{
    < ANY >
    {
        log.trace("meet token in <ANY>: " + getToken(0).image);
        return getToken(0).image;
    }
}

String ParenExpress() :
{
    String innerString;
    StringBuilder transformed = new StringBuilder();
}
{
    < LPAREN >
    (
        innerString = Expression()
        {
            transformed.append(innerString);
        }
    )*
    < RPAREN >
    {
        return "(" + transformed.toString() + ")";
    }
}

String EscapeExpress() :
{
    String innerString;
}
{
    < LBRACE >
    (< SPACE >)*
    (
        innerString = EscapeFunction()
    |   innerString = EscapeTimestamp()
    |   innerString = EscapeDate()
    |   innerString = EscapeTime()
    )
    (< SPACE >)*
    < RBRACE >
    {
        return innerString;
    }
}

String CastExpression() :
{
    String function;
    List<String> parameters = Lists.newArrayList();
}
{
    <CAST>
    {
        function = getToken(0).image;
    }
    (<SPACE> )* <LPAREN> (<SPACE>)*
    {
        parameters.add(ParameterExpression().trim());
    }
    (<SPACE>)*
    <AS>
    {
        parameters.add(getToken(0).image);
    }
    (<SPACE>)*
    {
        String type = dialect.transformDataType(ParameterExpression().trim());
        parameters.add(type);
    }
    (< SPACE >)* <RPAREN>
    {
        return String.format("%s(%s)", function, String.join(" ", parameters));
    }
}

String ExtractExpression() :
{
    String functionName;
    String parameter;
    ImmutableSet<String> timeunitSet = ImmutableSet.of("YEAR", "QUARTER", "MONTH", "WEEK",
        "DAY", "HOUR", "MINUTE", "SECOND", "DOW", "DOY");
}
{
    <EXTRACT> (<SPACE> )* <LPAREN> (<SPACE> )*
    {
        functionName = ParameterExpression().trim();
        if (!timeunitSet.contains(functionName.toUpperCase())) {
            throw new IllegalArgumentException(String.format(EXTRACT_FROM_EXCEPTION_MSG,
                functionName, String.join(", ", timeunitSet)));
        }
        if (functionName.equalsIgnoreCase("DAY")) {
            functionName = "DAYOFMONTH";
        } else if (functionName.equalsIgnoreCase("DOW")) {
            functionName = "DAYOFWEEK";
        } else if (functionName.equalsIgnoreCase("DOY")) {
            functionName = "DAYOFYEAR";
        }
    }
    (<SPACE>)* <FROM> (<SPACE>)*
    {
        parameter = ParameterExpression().trim();
    }
    (< SPACE >)* <RPAREN>
    {
        return dialect.transformFN(functionName, new String[]{ parameter });
    }
}

String TsDiffOrAddExpression() :
{
    String functionName;
    List<String> parameters = Lists.newArrayList();
    ImmutableSet<String> timeunitSet = ImmutableSet.of("YEAR", "QUARTER", "MONTH", "WEEK",
       "DAY", "HOUR", "MINUTE", "SECOND", "SQL_TSI_SECOND", "SQL_TSI_MINUTE", "SQL_TSI_HOUR",
       "SQL_TSI_DAY", "SQL_TSI_WEEK", "SQL_TSI_MONTH", "SQL_TSI_QUARTER","SQL_TSI_YEAR");
}
{
    (<TIMESTAMPDIFF> | <TIMESTAMPADD>)
    {
        functionName = getToken(0).image;
    }
    (< SPACE >)* <LPAREN> (< SPACE >)*
    {
        String timeunit = ParameterExpression().trim();
        if (!timeunitSet.contains(timeunit.toUpperCase())) {
            throw new IllegalStateException(String.format(TIMESTAMP_DIFF_ADD_EXCEPTION_MSG,
                functionName, timeunit, String.join(", ", timeunitSet)));
        }
        if (timeunit.toUpperCase().startsWith("SQL_TSI_")) {
            timeunit = timeunit.toUpperCase().replace("SQL_TSI_", "");
        }
        parameters.add(dialect.transformTimeunitOfTimestampDiffOrAdd(timeunit));
    }
    (< SPACE >)* <COMMA> (< SPACE >)*
    {
        parameters.add(ParameterExpression().trim());
    }
    (< SPACE >)* <COMMA> (< SPACE >)*
    {
        parameters.add(ParameterExpression().trim());
    }
    (< SPACE >)* <RPAREN>
    {
        return dialect.transformFN(functionName, parameters.toArray(new String [ 0 ]));
    }
}

String SubstringExpression():
{
    String functionName;
    List<String> parameters = Lists.newArrayList();
    List<String> params = Lists.newArrayList();
}
{
    (< SUBSTR > | < SUBSTRING > )
    {
        functionName = getToken(0).image;
    }
    (< SPACE >)* <LPAREN> (< SPACE >)*
    {
       parameters.add(ParameterExpression().trim());
    }
    (< SPACE >)* (<FROM> | <COMMA>) (<SPACE> )*
    {
        parameters.add(ParameterExpression().trim());
    }
    (
        (< SPACE >)* (< FOR > | <COMMA>) (< SPACE >)*
        {
           parameters.add(ParameterExpression().trim());
        }
    )?
    (< SPACE >)* < RPAREN >
    {
        return dialect.transformFN(functionName, parameters.toArray(new String [ 0 ]));
    }
}

String CeilFloorExpress() :
{
     String functionName;
     List <String> parameters = Lists.newArrayList();
     ImmutableSet<String> timeunitSet = ImmutableSet.of("YEAR", "QUARTER", "MONTH", "WEEK",
                           "DAY", "HOUR", "MINUTE", "SECOND");
}
{
    ( < CEIL > | < FLOOR > )
    {
        functionName = getToken(0).image;
    }
    (< SPACE >)* <LPAREN> (< SPACE >)*
    {
       parameters.add(ParameterExpression().trim());
    }
    (< SPACE >)*
    (
        <TO> (<SPACE>)*
        {
            String timeUnit = ParameterExpression().trim();
            if (!timeunitSet.contains(timeUnit.toUpperCase())) {
                throw new IllegalStateException(String.format(CEIL_FLOOR_EXCEPTION_MSG,
                    functionName, timeUnit, String.join(", ", timeunitSet)));
            }
            parameters.add(timeUnit);
        }
        (<SPACE>)*
    )?
    <RPAREN>
    {
        return dialect.transformFN(functionName, parameters.toArray(new String [ 0 ]));
    }
}

String EscapeFunction() :
{
    String functionName;
    String param;
    List <String> parameters = Lists.newArrayList();
    ImmutableSet<String> tsFunctions = ImmutableSet.of("TIMESTAMPDIFF", "TIMESTAMPADD");
}
{
    < FN >< FUNCTION_NAME >
    {
        functionName = getToken(0).image; 
    }
    < LPAREN > (<SPACE>)*
    (
        param = ParameterExpression()
        {
            if (tsFunctions.contains(functionName.trim().toUpperCase())) {
                if (param.toUpperCase().startsWith("SQL_TSI_")) {
                    param = param.toUpperCase().replace("SQL_TSI_", "");
                }
                parameters.add(dialect.transformTimeunitOfTimestampDiffOrAdd(param));
            } else {
                parameters.add(param);
            }
        }
        (
            < COMMA > EscapeFunctionParameter(parameters)
        )*
    )?
    < RPAREN >
    {
        return dialect.transformFN(functionName, parameters.toArray(new String [ 0 ]));
    }
}

void EscapeFunctionParameter(List<String> paramCollection) :
{
    String parameter = "";
}
{
    (
        parameter = ParameterExpression()
    )
    {
        paramCollection.add(parameter.trim());
    }
}

String ParameterExpression() :
{
    String innerString = "";
    String nextString = "";
}
{
    (
        innerString = EscapeExpress()
    | innerString = SubstringExpression()
    | innerString = CastExpression()
    | innerString = TsDiffOrAddExpression()
    | innerString = ExtractExpression()
    | innerString = CeilFloorExpress()
    | innerString = ParenExpress()
    | innerString = QuotedString()
    | innerString = DoubleQuotedString()
    | innerString = Space()
    | innerString = Punctuation()
    | innerString = Any()
    )
    (
        LOOKAHEAD(2)
        nextString = ParameterExpression()
    )?
    {
        return innerString + nextString;
    }
}

String EscapeTimestamp() :
{
    String timestampExpr;
}
{
    < TS >
    (< SPACE >)*
    (
        timestampExpr = QuotedString()
    )
    {
        return "TIMESTAMP " + timestampExpr;
    }
}

String EscapeDate() :
{
    String timestampExpr;
}
{
    (< DATE > | <D>)
    (< SPACE >)*
    (
        timestampExpr = QuotedString()
    )
    {
        return "DATE " + timestampExpr;
    }
}

String EscapeTime() :
{
    String timestampExpr;
}
{
    (< T > | <TIME>)
    (< SPACE >)*
    (
        timestampExpr = QuotedString()
    )
    {
        return "TIME " + timestampExpr;
    }
}

String BangEqual() :
{
}
{
    <BANGEQUAL>
    {
        return "<>";
    }
}
