<template>
  <el-form :model="measure" id="add-measure" label-position="right" :rules="rules" label-width="20%" ref="measureForm">

<!--     <el-form-item label="活动名称" prop="name">
      <el-input v-model="ruleForm.name"></el-input>
    </el-form-item>
    <el-form-item label="活动区域" prop="region">
      <el-select v-model="ruleForm.region" placeholder="请选择活动区域">
        <el-option label="区域一" value="shanghai"></el-option>
        <el-option label="区域二" value="beijing"></el-option>
      </el-select>
    </el-form-item> -->

    <el-form-item :label="$t('name')" prop="name">
      <div class="input_width">
        <el-input v-model="measure.name"></el-input>
      </div>
    </el-form-item>

    <el-form-item :label="$t('expression')">
      <span slot="label">{{$t('expression')}}
        <common-tip :content="$t('kylinLang.cube.expressionTip')" ><icon name="question-circle-o"></icon></common-tip>
      </span>
      <el-select v-model="measure.function.expression" class="input_width" @change="changeExpression">
        <el-option
          v-for="(item, index) in expressionsConf"
          :key="index"
          :label="item"
          :value="item">
        </el-option>
      </el-select>
    </el-form-item>

    <el-form-item :label="$t('paramType')" >
      <el-select v-model="measure.function.parameter.type" v-if="measure.function.expression ==='SUM'||measure.function.expression ==='TOP_N'" class="input_width" @change="changeParamType">
        <el-option
          v-for="(item, index) in type"
          :key="index"
          :label="item"
          :value="item">
        </el-option>
      </el-select>     
      <el-tag v-else>{{getParameterType}}</el-tag> 
    </el-form-item>
    <el-form-item>
      <el-checkbox v-model="showDim" v-if="measure.function.parameter.type !== 'constant'">{{$t('includeDimensions')}}</el-checkbox>
    </el-form-item>
    <el-form-item :label="getValueLab" >
    <span slot="label">{{getValueLab}}
        <common-tip :content="paramValTip" ><icon name="question-circle-o"></icon></common-tip>
      </span>
      <el-select v-model="measure.function.parameter.value" :placeholder="$t('kylinLang.common.pleaseSelect')" v-if="measure.function.parameter.type !== 'constant'" class="input_width" @change="changeParamValue" filterable>
        <el-option
          v-for="(item, index) in getParameterValue"
          :key="index"
          :label="item"
          :value="item">
          <span style="float: left">{{ item}}</span>
          <span style="float: right; color: #8492a6; font-size: 13px">{{modelDesc.columnsDetail && modelDesc.columnsDetail[item] && modelDesc.columnsDetail[item].datatype}}</span>
        </el-option>
      </el-select>
      <el-tag v-else>{{getParameterValue}}</el-tag>   
    </el-form-item>

    <el-form-item :label="$t('extendedColumn')"  v-if="measure.function.expression === 'EXTENDED_COLUMN'">
      <el-select v-model="nextParam.value" :placeholder="$t('kylinLang.common.pleaseSelect')" class="input_width" filterable>
        <el-option
          v-for="(item, index) in getAllModelDimColumns()"
          :key="index"
          :label="item"
          :value="item">
        </el-option>
      </el-select>     
    </el-form-item>     
    <el-form-item :label="getReturnTypeLab" >
      <el-tag v-if="measure.function.expression !== 'TOP_N' && measure.function.expression !== 'COUNT_DISTINCT' && measure.function.expression !== 'EXTENDED_COLUMN' && (measure.function.expression !== 'SUM' || measure.function.returntype.indexOf('decimal') > 0)">
        {{getReturnType}}
      </el-tag>
      <el-select v-model="measure.function.returntype" v-if="measure.function.expression === 'COUNT_DISTINCT'">
        <el-option
          v-for="(item, index) in distinctDataTypes"
          :key="index"
          :label="item.name"
          :value="item.value">
        </el-option>
      </el-select>
      <el-select v-model="measure.function.returntype" v-if="measure.function.expression === 'TOP_N'">
        <el-option
          v-for="(item, index) in topNTypes"
          :key="index"
          :label="item.name"
          :value="item.value">
        </el-option>
      </el-select>
      <el-input v-if="measure.function.expression === 'EXTENDED_COLUMN'" v-model="measure.function.returntype">
      </el-input>
      <el-row v-if="measure.function.expression === 'SUM'" >
        <el-row v-if="sumMeasure.type === 'decimal'" id="decimal">
          <span class="decimal-left">decimal(</span>
          <el-input v-model="sumMeasure.value.precision" class="precision"></el-input>
          <span class="douhao">,</span>
          <el-input v-model="sumMeasure.value.decimalPlace" class="place"></el-input>
          <span class="decimal-right">)</span>
        </el-row>
        <el-row v-if="sumMeasure.type === 'bigint'">
         <el-col  :span="4"><el-tag>bigint</el-tag></el-col>
        </el-row>
      </el-row>  
    </el-form-item> 

    <el-form-item v-if="measure.function.expression === 'COUNT_DISTINCT' && measure.function.returntype === 'bitmap'" >
      <el-checkbox v-model="isReuse" @change="changeReuse">{{$t('reuse')}}</el-checkbox>
    </el-form-item> 

    <el-form-item v-if="isReuse && measure.function.expression === 'COUNT_DISTINCT' && measure.function.returntype === 'bitmap'" :label="$t('reuse')" >
      <el-select v-model="reuseColumn">
        <el-option
          v-for="(item, key) in getCountDistinctBitMapColumn()"
          :key="key"
          :label="item"
          :value="item">
        </el-option>
      </el-select>
    </el-form-item> 

    <el-table id="table-measures" v-if="measure.function.expression === 'TOP_N' || (measure.function.expression === 'COUNT_DISTINCT' && measure.function.returntype !== 'bitmap')"
      style="width: 100%"
      :data="convertedColumns">
      <el-table-column
        :label="$t('ID')"
        width="100">
        <template scope="scope">
          <el-tag>{{scope.$index+1}}</el-tag>
        </template>
      </el-table-column>
      <el-table-column
        :label="$t('column')">
        <template scope="scope">
          <el-select v-model="scope.row.column" filterable>
           <el-option   
            v-for="(item, index) in getMultipleColumns"
            :label="item"
            :key="index"
            :value="item">
            </el-option>
          </el-select>
        </template>
      </el-table-column>
      <el-table-column v-if="measure.function.expression === 'TOP_N'"
        :label="$t('encoding')"
        width="180">
        <template scope="scope">
          <el-select v-model="scope.row.encoding" @change="changeEncoding(scope.row);">
            <el-option
              v-for="(item, index) in initEncodingType(scope.row)"
              :key="index"
              :label="item.name"
              :value="item.name + ':' + item.version">
              <el-tooltip effect="dark" :content="$t($store.state.config.encodingTip[item.name])" placement="top">
                <span style="float: left;width: 90%">{{ item.name }}</span>
                <span style="float: right;width: 10%; color: #8492a6; font-size: 13px" v-if="item.version>1">{{ item.version }}</span>
              </el-tooltip>
          </el-option>              
        </el-select>
      </template>
      </el-table-column>
      <el-table-column v-if="measure.function.expression === 'TOP_N'"
        :label="$t('length')"
        width="100">
        <template scope="scope">
          <el-input v-model="scope.row.valueLength"  :disabled="scope.row.encoding.indexOf('dict')>=0||scope.row.encoding.indexOf('date')>=0||scope.row.encoding.indexOf('time')>=0||scope.row.encoding.indexOf('boolean')>=0"></el-input>     
        </template>  
      </el-table-column>
      <el-table-column
        width="50">
        <template scope="scope">
          <el-button type="delete" icon="minus" size="mini" @click="removeProperty(scope.$index)"></el-button>
        </template>
      </el-table-column>
    </el-table>
    <el-row v-if="measure.function.expression === 'TOP_N' || (measure.function.expression === 'COUNT_DISTINCT' && measure.function.returntype !== 'bitmap') ">
     <el-col :span="24" >
    <el-button type="primary" icon="plus" size="mini" @click="addNewProperty" style="margin-top: 10px;">
      {{$t('newColumn')}}
    </el-button>
    </el-col>
  </el-row>
  </el-form>
</template>
<script>
import { loadBaseEncodings } from '../../../util/business'
import { objectClone } from '../../../util/index'
export default {
  name: 'add_measure',
  props: ['measureDesc', 'modelDesc', 'cubeDesc', 'measureFormVisible'],
  data () {
    return {
      measure: objectClone(this.measureDesc),
      expressionsConf: ['SUM', 'MIN', 'MAX', 'COUNT', 'COUNT_DISTINCT', 'TOP_N', 'RAW', 'EXTENDED_COLUMN', 'PERCENTILE'],
      type: ['constant', 'column'],
      showDim: false,
      isReuse: false,
      reuseColumn: '',
      isEdit: 'false',
      firstChange: true,
      convertedColumns: [],
      nextParam: {
        'type': 'column',
        'value': '',
        'next_parameter': null
      },
      sumMeasure: {
        type: '',
        value: {
          precision: 19,
          decimalPlace: 4
        }
      },
      distinctDataTypes: [
        {name: 'Error Rate < 9.75%', value: 'hllc(10)'},
        {name: 'Error Rate < 4.88%', value: 'hllc(12)'},
        {name: 'Error Rate < 2.44%', value: 'hllc(14)'},
        {name: 'Error Rate < 1.72%', value: 'hllc(15)'},
        {name: 'Error Rate < 1.22%', value: 'hllc(16)'},
        {name: 'Precisely', value: 'bitmap'}
      ],
      topNTypes: [
        {name: 'Top 10', value: 'topn(10)'},
        {name: 'Top 100', value: 'topn(100)'},
        {name: 'Top 1000', value: 'topn(1000)'}
      ],
      rules: {
        name: [
            { required: true, message: this.$t('requiredName'), trigger: 'blur' },
            { validator: this.validateName, trigger: 'blur' }
        ]
      }
    }
  },
  methods: {
    validateName (rule, value, callback) {
      let nameReuse = false
      let measureIndex = this.cubeDesc.measures.indexOf(this.measureDesc)
      let nameReuseIndex = -1
      if (!value) {
        callback(new Error(this.$t('requiredName')))
      } else {
        for (let i = 0; i < this.cubeDesc.measures.length; i++) {
          if (this.cubeDesc.measures[i].name === this.measure.name) {
            nameReuse = true
            nameReuseIndex = i
          }
        }
        if (nameReuse === true) {
          if (measureIndex >= 0 && measureIndex === nameReuseIndex) {
            callback()
          } else {
            callback(new Error(this.$t('nameReuse')))
          }
        } else {
          callback()
        }
      }
    },
    inModelDimensions: function () {
      let _this = this
      if (_this.measure.function.parameter.value) {
        _this.isEdit = true
        if (_this.modelDesc.metrics && _this.modelDesc.metrics.indexOf(_this.measure.function.parameter.value) !== -1) {
          _this.showDim = false
        } else {
          _this.showDim = true
        }
      } else {
        _this.showDim = false
        _this.sumMeasure.type = ''
      }
    },
    getExtendedHostColumn: function () {
      let columns = []
      let _this = this
      _this.cubeDesc.dimensions.forEach(function (dimension, index) {
        if (_this.modelDesc.factTables.indexOf(dimension.table) === -1) {
          return
        }
        if (dimension.column && dimension.derived == null) {
          columns.push(dimension.table + '.' + dimension.column)
        }
      })
      return columns
    },
    getCommonMetricColumns: function () {
      let columns = []
      if (this.modelDesc.metrics) {
        this.modelDesc.metrics.forEach(function (metric, index) {
          columns.push(metric)
        })
      }
      return columns
    },
    getAllModelDimMeasureColumns: function () {
      let columns = []
      this.modelDesc.dimensions.forEach(function (dimension, index) {
        if (dimension.columns) {
          dimension.columns.forEach(function (column) {
            columns = columns.concat(dimension.table + '.' + column)
          })
        }
      })
      if (this.modelDesc.metrics) {
        this.modelDesc.metrics.forEach(function (metric, index) {
          columns.push(metric)
        })
      }
      return columns
    },
    getAllModelDimColumns: function () {
      let columns = []
      this.modelDesc.dimensions.forEach(function (dimension, index) {
        if (dimension.columns) {
          dimension.columns.forEach(function (column) {
            columns.push(dimension.table + '.' + column)
          })
        }
      })
      return columns
    },
    initExtendedColumn: function () {
      if (this.measure.function.expression === 'EXTENDED_COLUMN') {
        this.$nextTick(() => {
          this.nextParam.value = this.measure.function.parameter.next_parameter.value || ''
          let returnValue = /\((\d+)\)/.exec(this.measure.function.returntype)
          this.measure.function.returntype = returnValue[1]
        })
      }
    },
    initSumColumn: function () {
      this.convertedColumns.splice(0, this.convertedColumns.length)
      if (this.measure.function.expression === 'SUM' && this.measure.function.parameter.type === 'column') {
        this.$nextTick(() => {
          let returnValue = this.measure.function.returntype.match(RegExp('^.*?\\((\\d+)\\,(\\d+)\\)$'))
          if (returnValue) {
            this.sumMeasure.type = 'decimal'
            this.sumMeasure.value.precision = returnValue[1]
            this.sumMeasure.value.decimalPlace = returnValue[2]
          } else {
            this.sumMeasure.type = 'bigint'
          }
        })
      }
    },
    initCountDistinctColumn: function () {
      if (this.measure.function.expression === 'COUNT_DISTINCT') {
        this.$nextTick(() => {
          if (this.cubeDesc.dictionaries) {
            this.cubeDesc.dictionaries.forEach((dictionary) => {
              if (dictionary.reuse && dictionary.column === this.measure.function.parameter.value) {
                this.reuseColumn = dictionary.reuse
                this.isReuse = true
              } else {
                this.isReuse = false
                this.reuseColumn = ''
              }
            })
          }
          if (this.measure.function.parameter.next_parameter) {
            this.recursion(this.measure.function.parameter.next_parameter, this.convertedColumns)
          }
        })
      }
    },
    getCountDistinctBitMapColumn: function () {
      let columns = []
      if (this.cubeDesc.measures) {
        this.cubeDesc.measures.forEach(function (metric, index) {
          if (metric.function.expression === 'COUNT_DISTINCT' && metric.function.returntype === 'bitmap') {
            columns.push(metric.function.parameter.value)
          }
        })
      }
      return columns
    },
    initGroupByColumn: function () {
      if (this.measure.function.configuration && this.measure.function.expression === 'TOP_N') {
        this.$nextTick(() => {
          let returnValue = (/\((\d+)(,\d+)?\)/).exec(this.measure.function.returntype)
          this.measure.function.returntype = 'topn(' + returnValue[1] + ')'
          if (this.measure.function.parameter.next_parameter) {
            this.recursion(this.measure.function.parameter.next_parameter, this.convertedColumns)
            this.convertedColumns.forEach((column) => {
              let item = this.measure.function.configuration['topn.encoding.' + column.column]
              let _encoding = this.getEncoding(item)
              let _valueLength = this.getLength(item)
              let version = this.measure.function.configuration['topn.encoding_version.' + column.column] || 1
              this.$set(column, 'encoding', _encoding + ':' + version)
              this.$set(column, 'valueLength', _valueLength)
            })
          }
        })
      }
    },
    changeEncoding (row) {
      if (this.getEncoding(row.encoding) === 'integer') {
        row.valueLength = 4
      } else {
        row.valueLength = ''
      }
    },
    initEncodingType: function (column) {
      let _this = this
      let baseEncodings = loadBaseEncodings(_this.$store.state.datasource)
      if (column.column) {
        let _this = this
        let datatype = _this.modelDesc.columnsDetail[column.column].datatype
        let filterEncodings = baseEncodings.filterByColumnType(datatype)
        if (this.isEdit) {
          let _encoding = _this.getEncoding(column.encoding)
          let _version = parseInt(_this.getVersion(column.encoding))
          let addEncodings = baseEncodings.addEncoding(_encoding, _version)
          return addEncodings
        } else {
          return filterEncodings
        }
      } else {
        return [{name: 'dict', version: baseEncodings.getEncodingMaxVersion('dict')}]
      }
    },
    getEncoding: function (encode) {
      if (encode) {
        let code = encode.split(':')
        return code[0]
      }
    },
    getLength: function (encode) {
      if (encode) {
        let code = encode.split(':')
        return code[1]
      }
    },
    getVersion: function (encode) {
      if (encode) {
        let code = encode.split(':')
        return code[1]
      }
    },
    removeProperty: function (index) {
      this.convertedColumns.splice(index, 1)
    },
    addNewProperty: function () {
      let _this = this
      if (_this.measure.function.expression === 'TOP_N') {
        let baseEncodings = loadBaseEncodings(_this.$store.state.datasource)
        let GroupBy = {
          column: '',
          encoding: 'dict:' + baseEncodings.getEncodingMaxVersion('dict'),
          valueLength: 0
        }
        _this.convertedColumns.push(GroupBy)
      } else {
        let GroupBy = {
          column: ''
        }
        _this.convertedColumns.push(GroupBy)
      }
    },
    recursion: function (parameter, list) {
      let _this = this
      list.push({column: parameter.value})
      if (parameter.next_parameter) {
        _this.recursion(parameter.next_parameter, list)
      } else {
        return
      }
    },
    changeReuse: function () {
      if (this.isReuse === false) {
        this.reuseColumn = ''
      }
    },
    changeParamType: function () {
      if (this.measure.function.parameter.value === 1 && this.measure.function.parameter.type === 'column') {
        this.measure.function.parameter.value = ''
      }
    },
    changeExpression: function () {
      if (!this.firstChange && this.measure.function.expression === 'TOP_N') {
        this.measure.function.returntype = 'topn(100)'
      }
      if (!this.firstChange && this.measure.function.expression === 'COUNT_DISTINCT') {
        this.measure.function.returntype = 'hllc(10)'
      }
      if (!this.firstChange && this.measure.function.expression === 'EXTENDED_COLUMN') {
        this.measure.function.returntype = '100'
      }
      if (!this.firstChange && this.measure.function.expression === 'PERCENTILE') {
        this.measure.function.returntype = 'percentile(100)'
      }
      if (!this.firstChange && this.measure.function.expression === 'SUM') {
        if (this.measure.function.parameter.value !== '' && this.measure.function.parameter.type === 'column') {
          let colType = this.modelDesc.columnsDetail[this.measure.function.parameter.value].datatype
          if (colType === 'smallint' || colType === 'int' || colType === 'bigint' || colType === 'integer' || colType === 'tinyint') {
            this.sumMeasure.type = 'bigint'
          } else {
            this.sumMeasure.type = 'decimal'
            if (colType.indexOf('decimal') !== -1 || colType === 'double' || colType === 'float') {
              this.sumMeasure.value.precision = 19
              this.sumMeasure.value.decimalPlace = 4
            } else {
              this.sumMeasure.value.precision = 14
              this.sumMeasure.value.decimalPlace = 0
            }
          }
        }
        if (this.measure.function.parameter.value === 1 && this.measure.function.expression !== 'SUM' && this.measure.function.expression !== 'COUNT' && this.measure.function.expression !== 'TOP_N') {
          this.measure.function.parameter.value = ''
        }
      }
      this.firstChange = false
    },
    changeParamValue: function () {
      if (this.measure.function.expression === 'SUM' && this.measure.function.parameter.value !== '' && this.measure.function.parameter.type === 'column') {
        let colType = this.modelDesc.columnsDetail[this.measure.function.parameter.value].datatype
        if (colType === 'smallint' || colType === 'int' || colType === 'bigint' || colType === 'integer' || colType === 'tinyint') {
          this.sumMeasure.type = 'bigint'
        } else {
          this.sumMeasure.type = 'decimal'
          if (colType.indexOf('decimal') !== -1 || colType === 'double' || colType === 'float') {
            this.sumMeasure.value.precision = 19
            this.sumMeasure.value.decimalPlace = 4
          } else {
            this.sumMeasure.value.precision = 14
            this.sumMeasure.value.decimalPlace = 0
          }
        }
      }
    },
    initHiddenFeature: function () {
      if (this.$store.state.config.hiddenFeature['raw-measure'] === true && this.expressionsConf.indexOf('RAW') >= 0) {
        this.expressionsConf.splice(this.expressionsConf.indexOf('RAW'), 1)
      }
      if (this.$store.state.config.hiddenFeature['extendedcolumn-measure'] === true && this.expressionsConf.indexOf('EXTENDED_COLUMN') >= 0) {
        this.expressionsConf.splice(this.expressionsConf.indexOf('EXTENDED_COLUMN'), 1)
      }
    }
  },
  computed: {
    getValueLab: function () {
      if (this.measure.function.expression === 'EXTENDED_COLUMN') {
        return this.$t('hostColumn')
      } else if (this.measure.function.expression === 'TOP_N') {
        return this.$t('ORDERSUM')
      } else {
        return this.$t('paramValue')
      }
    },
    paramValTip: function () {
      if (this.measure.function.expression === 'EXTENDED_COLUMN') {
        return this.$t('kylinLang.cube.hostColumnTip')
      } else if (this.measure.function.expression === 'TOP_N') {
        return this.$t('kylinLang.cube.orderSumTip')
      } else {
        return this.$t('kylinLang.cube.paramValueTip')
      }
    },
    getReturnTypeLab: function () {
      if (this.measure.function.expression === 'EXTENDED_COLUMN') {
        return this.$t('extendedColumnLength')
      } else {
        return this.$t('returnType')
      }
    },
    getParameterType: function () {
      if (this.measure.function.expression !== 'COUNT') {
        this.measure.function.parameter.type = 'column'
      } else {
        this.measure.function.parameter.type = 'constant'
      }
      return this.measure.function.parameter.type
    },
    getParameterValue: function () {
      if (this.measure.function.parameter.type === 'constant') {
        this.measure.function.parameter.value = 1
        return this.measure.function.parameter.value
      }
      if (this.measure.function.expression === 'EXTENDED_COLUMN') {
        return this.getExtendedHostColumn()
      } else {
        if (this.showDim === true) {
          return this.getAllModelDimMeasureColumns()
        }
        if (this.showDim === false) {
          return this.getCommonMetricColumns()
        }
      }
    },
    getReturnType: function () {
      if (this.measure.function.parameter.type === 'constant') {
        switch (this.measure.function.expression) {
          case 'SUM':
            this.measure.function.returntype = 'bigint'
            break
          case 'COUNT':
            this.measure.function.returntype = 'bigint'
            break
          default:
            this.measure.function.returntype = ''
            break
        }
      }
      if (this.measure.function.parameter.value !== '' && this.measure.function.parameter.value !== 1 && this.measure.function.parameter.type === 'column' && this.measure.function.expression !== 'COUNT_DISTINCT') {
        let colType = this.modelDesc.columnsDetail[this.measure.function.parameter.value].datatype
        switch (this.measure.function.expression) {
          case 'MIN':
            this.measure.function.returntype = colType
            break
          case 'MAX':
            this.measure.function.returntype = colType
            break
          case 'RAW':
            this.measure.function.returntype = 'raw'
            break
          case 'PERCENTILE':
            this.measure.function.returntype = 'percentile(100)'
            break
          default:
            this.measure.function.returntype = ''
            break
        }
      }
      return this.measure.function.returntype
    },
    getMultipleColumns: function () {
      if (this.measure.function.expression === 'TOP_N') {
        return this.getAllModelDimColumns()
      }
      if (this.measure.function.expression === 'COUNT_DISTINCT') {
        return this.getAllModelDimMeasureColumns()
      }
    }
  },
  watch: {
    measureFormVisible (measureFormVisible) {
      this.measure = objectClone(this.measureDesc)
      this.firstChange = true
      this.inModelDimensions()
      this.initHiddenFeature()
      this.initSumColumn()
      this.initExtendedColumn()
      this.initGroupByColumn()
      this.initCountDistinctColumn()
    }
  },
  created () {
    let _this = this
    this.inModelDimensions()
    this.initHiddenFeature()
    this.initSumColumn()
    this.initExtendedColumn()
    this.initGroupByColumn()
    this.initCountDistinctColumn()
    this.$on('measureFormValid', (t) => {
      _this.$refs['measureForm'].validate((valid) => {
        if (valid) {
          _this.$emit('validSuccess', {measure: _this.measure, convertedColumns: _this.convertedColumns, reuseColumn: _this.reuseColumn, sumMeasure: _this.sumMeasure, nextParam: _this.nextParam})
        }
      })
    })
  },
  locales: {
    'en': {name: 'Name', expression: 'Expression', paramType: 'Param Type', paramValue: 'Param Value', returnType: 'Return Type', includeDimensions: 'Include Dimensions', ORDERSUM: 'ORDER|SUM by Column', groupByColumn: 'Group by Column', ID: 'ID', column: 'Column', encoding: 'Encoding', length: 'Length', hostColumn: 'Host column On Fact Table', extendedColumn: 'Extended column On Fact Table', extendedColumnLength: 'Maximum length of extended column', reuse: 'Reuse', newColumn: 'New Column', requiredName: 'The measure name is required.', nameReuse: 'The measure name is reused.'},
    'zh-cn': {name: '名称', expression: '表达式', paramType: '参数类型', paramValue: '参数值', returnType: '返回类型', includeDimensions: '包含维度', ORDERSUM: 'ORDER|SUM by Column', groupByColumn: 'Group by Column', ID: 'ID', column: '列', encoding: '编码', length: '长度', hostColumn: 'Host column On Fact Table', extendedColumn: 'Extended column On Fact Table', extendedColumnLength: 'Maximum length of extended column', reuse: '复用', newColumn: '新加列', requiredName: '请输入Measure名称', nameReuse: 'Measure名称已被使用'}
  }
}
</script>
<style lang="less">
  @import '../../../less/config.less';
  .input_width{
    width: 90%!important;
  }
  #table-measures{
    .el-table__row{
      background: @input-bg;
    }
    .el-table__row:hover td{
      background: @input-bg!important;
    }
    .el-input{
      padding-bottom: 0;
      padding-top: 0;
    }
    .el-input__inner{
      background: @input-bg;
    }
    .el-tag{
      top: 0!important;
      background: transparent;
    }
    .el-button--mini{
      background: #ff4949;
    }
  }
  #add-measure{
    .el-input{
      padding-bottom: 0;
    }
    .el-form-item__label{
      // line-height: 36px;
    }
    // .el-form-item{
    //   margin-bottom: 0;
    // }
    .el-icon-caret-top{
      height: 36px;
      line-height: 36px;
    }
    .el-tag{
      position: relative;
      top: 12px;
    }
    .el-dialog__body .el-input{
      padding: 0!important;
    }
  }
  #decimal{
    span, .el-input{
      float: left;
      margin-left: 5px;
    }
    .decimal-left{
      margin-top: 10px;
    }
    .el-input{
      padding-top: 0;
      margin-top: 10px;
      width: 38px;
    }
    .douhao{
      margin-top: 5px;
    }
    .decimal-right{
      margin-top: 10px;
    }
  }
</style>
